######## Ex 4.5: Drawing factals, by Cheng
# http://en.wikipedia.org/wiki/Mandelbrot_set

### test using complex numbers
# http://www.johnmyleswhite.com/notebook/2009/12/18/using-complex-numbers-in-r/

as.complex(0)

as.complex(1)

as.complex(1i)

1+1i
Mod(1+1i)  # distance to origin
Arg(1+1i)

### test the sequence z_n+1 = z_n^2 + c related to Mandelbrot set 

c <- 1 
# letting c = 1 gives the sequence 0, 1, 2, 5, 26

N <- 100   			# desired length of the sequence
z <- numeric(N)  	# allocate a vector to store z
z[1] = 0

for (i in 2:N) {
	z[i] <- z[i-1]^2 + c
}

z

### wrap the test into a function

test_seq <- function(c = 1, N = 100) {
# c: paramter of the sequence z_n+1 = z_n^2 + c
# N: desired length of the sequence
# letting c = 1 gives the sequence 0, 1, 2, 5, 26

	z <- numeric(N)  	# allocate a vector to store z
	z[1] = 0

	for (i in 2:N) {
		z[i] <- z[i-1]^2 + c
	}

	return(z)
} 

test_seq(1)  # qucikly go to infinity, 1 is not in the Mandelbrot set

test_seq(1i) # bouned, i is in the Mandelbrot set
# nice that my function just works for complex numbers

test_seq(1+8i)


### determine whether a point is in the Mandelbrot set

# http://en.wikipedia.org/wiki/Mandelbrot_set#Computer_drawings

# Wiki: For values within the Mandelbrot set, escape will never occur.

# Wiki_2: Because no complex number with a real or imaginary part greater 
# than 2 can be part of the set, a common bailout is to escape 
# when either coefficient exceeds 2.

# Wiki_3: detects escapes sooner, is to compute the distance from 
# the origin using the Pythagorean theorem, and if this distance 
# exceeds two, the point has reached escape.

### 1st version and crude: escape at 100 steps?
MaxStep <- 100
z <- numeric(N)  	# global storage to reduce memory allocation time
z[1] = 0

escape_steps <- function(x, y, max_step = 100) {
	c <- complex(real = x, imaginary = y)

	for (i in 2:max_step) {
		z[i] <- z[i-1]^2 + c
		
		# does the point escape the radius of 2? see comments Wiki_3 above
		if (Mod(z[i]) > 2)
			break    # break the for() loop
	}
	
	return(i)  
	# if i < max_step, escape occurs, (x,y) not in the Mandelbrot set
}

escape_steps(1, 1)  # 3; 

escape_steps(1, 0) 	# 4

escape_steps(0, 1) 	# 1i; 100; potentally in the the Mandelbrot set


### try to make the first plot in [-1,1] on both x and y

spacing <- 0.01  # plot pixels at such spacing
# spacing <- 0.1  # for testing the plot; avoid waiting time
#x_range <- seq(-1, 1, spacing)
x_range <- seq(-2, 1, spacing)  # shit towards left
y_range <- seq(-1, 1, spacing)

plot(c(), c(), xlim=c(-2,1), ylim=c(-1,1), type="n", 
	xlab="", ylab="", main="Mandelbrot set",asp=1)

for (x in x_range) {
	for (y in y_range) {
		if (escape_steps(x, y) == MaxStep) {
			# potentially in the Mendelbrot set, plot the point
			points(x, y, pch=22, col="black", bg="black", cex=0.1)
			# filled squre; cex is to reduce the point size
		}
	}
}

### trun this into a function that takes a region

plot_mendelbrot <- function(x1, x2, y1, y2, resolution = 100) {
	# x1, y1 are lower left
	# x2, y2 are upper right
	# resolution is the number of points on both axes
	
	x_range <- seq(x1, x2, length.out = resolution)  # shit towards left
	y_range <- seq(y1, y2, length.out = resolution)

	plot(c(), c(), xlim=c(x1,x2), ylim=c(y1,y2), type="n", 
		xlab="", ylab="", main="Mandelbrot set",asp=1)

	for (x in x_range) {
		for (y in y_range) {
			if (escape_steps(x, y) == MaxStep) {
				# potentially in the Mendelbrot set, plot the point
				point_size <- 15 / resolution   # 0.15 for resolution 100
				points(x, y, pch=22, col="black", bg="black", cex=point_size)
				# filled squre; cex is to reduce the point size
			}
		}
	}
}

plot_mendelbrot(-2, 1, -1, 1) # reproduce the previous plot

plot_mendelbrot(-1, -0.5, -.3, .3) # zoom in on the neck region

# an interseting point to zoom around, from Wiki:
# 0.001643721971153 + 0.822467633298876i
plot_one_region <- function(x0 = 0.001643721971153, y0 = 0.822467633298876, size = 0.1) {
	plot_mendelbrot(x0 - size, x0 + size, y0 - size, y0 + size, resolution=500)
}

plot_one_region()

plot_one_region(size = 1e-6)


### color the points by escape steps: black for MaxStep, lighter for shorter steps

color_scale <- rev(heat.colors(100)) 
plot(1:100, pch=22, cex=2, col=color_scale)  # light colors for smaller values

plot_mendelbrot_color <- function(x1, x2, y1, y2, resolution = 100) {
	# x1, y1 are lower left
	# x2, y2 are upper right
	# resolution is the number of points on both axes
	
	x_range <- seq(x1, x2, length.out = resolution)  # shit towards left
	y_range <- seq(y1, y2, length.out = resolution)

	plot(c(), c(), xlim=c(x1,x2), ylim=c(y1,y2), type="n", 
		xlab="", ylab="", main="Mandelbrot set in color",asp=1)

	for (x in x_range) {
		for (y in y_range) {
			num_steps <- escape_steps(x, y)
			color <- color_scale[num_steps]
			if (num_steps == MaxStep) {
				color = "black"
			}
			# potentially in the Mendelbrot set, plot the point
			point_size <- 15 / resolution   # 0.15 for resolution 100
			
			points(x, y, pch=22, col=color, bg=color, cex=point_size)
			# filled squre; cex is to reduce the point size
			
		}
	}
}

plot_mendelbrot_color(-2, 1, -1, 1) # reproduce the previous plot

plot_mendelbrot_color(-1, -0.5, -.3, .3) # zoom in on the neck region

plot_one_region_color <- function(x0 = 0.001643721971153, y0 = 0.822467633298876, size = 0.1) {
	plot_mendelbrot_color(x0 - size, x0 + size, y0 - size, y0 + size, resolution=500)
}

plot_one_region_color()

plot_one_region_color(size = 1e-6)

plot_one_region_color(size = 1e-7)

### possible futher improvements:
# speed up the escape computation and ploting
# plot a pixel rather than a point of unknown size