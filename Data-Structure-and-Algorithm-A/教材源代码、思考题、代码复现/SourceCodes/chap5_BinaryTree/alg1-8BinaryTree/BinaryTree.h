//************BinaryTree.h****************//

#include <stack>
#include <queue>
#include "BinaryTreeNode.h"

enum Tags{Left,Right};    //???????

template <class T>
class StackElement  {         //StackElement
public:
	BinaryTreeNode<T>* pointer;
	Tags tag;
};	

using namespace std;

template <class T>
class BinaryTree {
private:
	BinaryTreeNode<T>*  root;      			//???????????
public:
	BinaryTree(){root = NULL;};				//??????
	~BinaryTree() {DeleteBinaryTree(root);};	//????????
	bool isEmpty() const;						//?Дп???????????????
	BinaryTreeNode<T>* Root(){return root;};	//??????????????
	BinaryTreeNode<T>* Parent(BinaryTreeNode<T>* current);//????current??????
	BinaryTreeNode<T>* LeftSibling(BinaryTreeNode<T>* current);
	//????current?????????
	BinaryTreeNode<T>* RightSibling(BinaryTreeNode<T>* current);
	//????current?????????
	void CreateTree(const T& info, BinaryTree<T>& leftTree, BinaryTree<T>& rightTree);
	//?????????info?????leftTree??rightTree??????????????????
	void PreOrder(BinaryTreeNode<T>* root);  	//??????дк?????????????
	void InOrder(BinaryTreeNode<T>* root);		//???????дк?????????????
	void PostOrder(BinaryTreeNode<T>* root);	//???????дк?????????????
	void PreOrderWithoutRecursion(BinaryTreeNode<T>* root);//??????????дк?????????????
	void InOrderWithoutRecursion(BinaryTreeNode<T>* root);//???????????дк?????????????
	void PostOrderWithoutRecursion(BinaryTreeNode<T>* root);//??????????дк?????????????
	void LevelOrder(BinaryTreeNode<T>* root); 	//????????дк?????????????
	void DeleteBinaryTree(BinaryTreeNode<T>* root);	//?????????????????
	void Visit(T Value) {cout << Value;};           //????
};


//**********  BianryTree Implementation  ***********//

template<class T>
bool BinaryTree<T>:: isEmpty() const  {      //?Дп???????????????
	return ( root? false : true);
}

template<class T>
BinaryTreeNode<T>* BinaryTree<T>::Parent(BinaryTreeNode<T>* current)  {
	using std::stack;						//???STL?До?stack
	stack<BinaryTreeNode<T>* > aStack;
	BinaryTreeNode<T>* pointer = root;      	//???????????	
	if(NULL != root && NULL != current)  {		
		while(!aStack.empty() || pointer)	{
			if (pointer)  {
				if(current == pointer->leftchild() ||current == pointer->rightchild()) //??????pointer????????current??????parent
					return pointer;
				aStack.push(pointer);				//???????????
				pointer = pointer->leftchild();		//???????????????
			}
			else  {                         //??????????????????????????
				pointer = aStack.top();			//?????????                 
				aStack.pop();
				pointer = pointer->rightchild();  	//????????????????
			}//endif
		} //endwhile
	}//endif
}


template<class T>
BinaryTreeNode<T>* BinaryTree<T>::LeftSibling(BinaryTreeNode<T>* current)  {
	//????current?????????
	if(current)  {
		BinaryTreeNode<T>* temp = Parent(current);    //????current????????
		if ((temp == NULL) || current == temp->leftchild())
			return  NULL;	  //????????????????current??????????????
		else return temp->leftchild();
	}
	return NULL;
}

template<class T>
BinaryTreeNode<T>* BinaryTree<T>::RightSibling(BinaryTreeNode<T>* current)  {
	//????current?????????
	if(current)  {
		BinaryTreeNode<T>* temp = Parent(current);//????current????????
		if(temp == NULL||current == temp->rightchild())
			return  NULL;		    //????????????????current????????
		else return temp->rightchild();
	}
	return NULL;
}

template<class T>
void BinaryTree<T>:: CreateTree (const T& info, BinaryTree<T>& leftTree, BinaryTree<T>& rightTree)  {
	//????????leftTree????????rightTree?????????info????????????????????info
	//????this??leftTree??rightTree????????????????
	root = new BinaryTreeNode<T>(info, leftTree.root, rightTree.root);	//????????
	leftTree.root = rightTree.root = NULL;  //????????????????????????????
}

template<class T>
void BinaryTree<T>:: DeleteBinaryTree(BinaryTreeNode<T>* root)  { //????????д┼????????????
	if(root)  {
		DeleteBinaryTree(root->left);				//????????????
		DeleteBinaryTree(root->right);		    //????????????
		delete root;							//????????
	}
}

template<class T>
void BinaryTree<T>::PreOrder (BinaryTreeNode<T>* root)  {  //??????дк?????
	if(root != NULL)  {
		Visit(root->value());						//?????????
		PreOrder(root->leftchild());			//??????????
		PreOrder(root->rightchild());			//??????????
	}
}
template<class T>
void BinaryTree<T>:: InOrder (BinaryTreeNode<T>* root)  {  //???????дк?????
	if(root != NULL)  {
		InOrder (root->leftchild());			//??????????
		Visit(root->value());						//?????????
		InOrder (root->rightchild());			//??????????
	}
}
template<class T>
void BinaryTree<T>:: PostOrder (BinaryTreeNode<T>* root)  { //???????дк?????
	if(root != NULL)  {
		PostOrder(root->leftchild());			//??????????
		PostOrder (root->rightchild());		//??????????
		Visit(root->value());						//?????????
	}
}

template<class T>
void BinaryTree<T>::PreOrderWithoutRecursion(BinaryTreeNode<T>* root)  {//??????????дк?????????????
	using std::stack;						//???STL?До?stack
	stack<BinaryTreeNode<T>* > aStack;
	BinaryTreeNode<T>* pointer = root;      	//???????????	
	while(!aStack.empty() || pointer)	{
		if (pointer)  {
			Visit(pointer->value());			//?????????
			aStack.push(pointer);				//???????????
			pointer = pointer->leftchild();		//???????????????
		}
		else  {                         //??????????????????????????
			pointer = aStack.top();			//?????????                 
			aStack.pop();
			pointer = pointer->rightchild();  	//????????????????
		}//endif
    } //endwhile
}

template<class T>
void BinaryTree<T>::InOrderWithoutRecursion(BinaryTreeNode<T>* root)  {
	//???????????дк?????????????
	using std::stack;							//???STL?До?stack
	stack<BinaryTreeNode<T>* > aStack;
	BinaryTreeNode<T>* pointer = root;      	//???????????	
	while(!aStack.empty() || pointer)  {
		if (pointer)  {
			aStack.push(pointer);				//???????????
			pointer = pointer->leftchild();		//???????????????
		}
		else  {                            //??????????????????????????
			pointer = aStack.top();
			aStack.pop();					//?????????    
			Visit(pointer->value());		//?????????
			pointer = pointer->rightchild(); 	//????????????????             
		}
	} //endwhile
}

template<class T>
void BinaryTree<T>::PostOrderWithoutRecursion(BinaryTreeNode<T>* root)  {
	//??????????дк?????????????
	using std::stack;							//???STL?????
	StackElement<T> element;
	stack<StackElement<T > > aStack;			//?????
	BinaryTreeNode<T>* pointer;
	if(root == NULL)
		return;							//??????????
	else pointer = root;						//???????????

    while (!aStack.empty() || pointer) {
		while (pointer != NULL) {
			element.pointer = pointer;
			element.tag = Left;
			aStack.push(element);
			pointer = pointer->leftchild();		//????????????????????
		}

		element = aStack.top();
		aStack.pop();							//?Дн???????
		pointer = element.pointer;

		if (element.tag == Left){
			//????????????
			element.tag = Right;
			aStack.push(element);
			pointer = pointer->rightchild();
		}
		else {                                  //????????????
			Visit(pointer->value());		    //?????????
			pointer = NULL;
		}
	}
}

template<class T>
void BinaryTree<T>::LevelOrder(BinaryTreeNode<T>* root)	{
	//????????дк?????????????
	using std::queue;							//???STL?????
	queue<BinaryTreeNode<T>*> aQueue;
	BinaryTreeNode<T>* pointer = root;			//???????????
	if (pointer)
		aQueue.push(pointer);                  //??????????
	while (!aQueue.empty())  {                 //???Д┘??
		pointer = aQueue.front();			 	//?????????
		aQueue.pop();                        //???????????
        Visit(pointer->value());					//?????????
		if(pointer->leftchild())
			aQueue.push(pointer->leftchild());		//????????????
		if(pointer->rightchild())
			aQueue.push(pointer->rightchild());	//????????????
	}
}