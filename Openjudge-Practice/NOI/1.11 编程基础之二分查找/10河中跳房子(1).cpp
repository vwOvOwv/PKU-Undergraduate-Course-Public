/*
D:河中跳房子
查看提交统计提问
总时间限制: 1000ms 内存限制: 65536kB

描述
每年奶牛们都要举办各种特殊版本的跳房子比赛，包括在河里从一个岩石跳到另一个岩石。这项激动人心的活动在一条长长的笔直河道中进行，
在起点和离起点L远 (1 ≤ L≤ 1,000,000,000) 的终点处均有一个岩石。在起点和终点之间，有N (0 ≤ N ≤ 50,000) 个岩石，每个岩石与
起点的距离分别为Di (0 < Di < L)。
在比赛过程中，奶牛轮流从起点出发，尝试到达终点，每一步只能从一个岩石跳到另一个岩石。当然，实力不济的奶牛是没有办法完成目标的。
农夫约翰为他的奶牛们感到自豪并且年年都观看了这项比赛。但随着时间的推移，看着其他农夫的胆小奶牛们在相距很近的岩石之间缓慢前行，
他感到非常厌烦。他计划移走一些岩石，使得从起点到终点的过程中，最短的跳跃距离最长。他可以移走除起点和终点外的至多M (0 ≤ M ≤ N)
个岩石。
请帮助约翰确定移走这些岩石后，最长可能的最短跳跃距离是多少？

输入
第一行包含三个整数L, N, M，相邻两个整数之间用单个空格隔开。
接下来N行，每行一个整数，表示每个岩石与起点的距离。岩石按与起点距离从近到远给出，且不会有两个岩石出现在同一个位置。
输出
一个整数，最长可能的最短跳跃距离。
样例输入
25 5 2
2
11
14
17
21
样例输出
4
提示
在移除位于2和14的两个岩石之后，最短跳跃距离为4（从17到21或从21到25）。
*/
#include<iostream>
#include<vector>
using namespace std;
int l,m,n;
int ri[50010];
bool judge(int mid){
	int cnt=0;//应当删去的石头个数
	int std=ri[0];
	for(int i=1;i<=n+1;i++){
		if(ri[i]-std<mid)
			cnt++;
		else
			std=ri[i];//注意变更参考点
	}
	if(cnt>m)//删的太多了
		return false;
	else
		return true;
}
int main()
{
	cin>>l>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>ri[i];
	ri[0]=0;
	ri[n+1]=l;
	int L=1,R=l,mid;//mid即为假定的最短跳跃距离,注意这里的查找区间是[L,R]
	while(L<R){
		mid=L+(R-L)/2;
		if(!judge(mid))//删的多了，要缩小mid
			R=mid-1;
		else
			L=mid+1;
	}
	cout<<R<<endl;//L,mid or R?Try.
	return 0;
}
