/*
要使得拆分后得到的乘积最大，那么拆分因子不考虑1，因为对乘积毫无贡献,还使得可以分配的和减小了
对于a=b+c(a、b、c是大于1的正整数)，bc总是大于b+c的，所以对于一个正整数n拆分的因子越多越好(譬如a拆成bc，再继续把b拆成因子相乘，乘积不断增大)又由于要求拆分的各因子不同，为了把有限的和拆成尽可能多的因子，要往小了拆
比如把n拆成 2、3、4、……k之后发现剩余的值x小于k+1,不能再拆出k+1这个因子了，那么x只能加到前面的某个/些因子上。
如果x等于1，那么x只能加到前面的某个因子上，如果单独做一个因子对乘积的增长不会有贡献
如果x不等于1， 那么x只能加到前面的某些因子上，如果x单独作为一个因子,又已知x小于k+1，那么x就在2~k之间，是已经取过的因子，不能重复
那么把x一个一个拆分地分配到已有的因子上(为什么要一个1一个1地拿？
为了乘积最大，各个因子的值要尽可能接近，更精确的解释是要尽可能地分配到更小的因子上，才能使得乘积每次增大的幅度最大)，为了乘积最大，很容易想到从更小的因子分配，因为这样乘积的增长幅度更大，但是从小的开始增长就会造成和更大的因子重复的情况，因此从更大的因子分配
这样仍然可能有剩余，但最多剩余1, 因为再多就足够构成下一个乘数k+1的了，同样为了避免重复，我们只能将这个1加在最大的乘数上。
*/
#include<iostream>
#include<algorithm>
#include<iomanip>
#include<vector>
#include<climits>
using namespace std;
int main()
{
	int n;
	cin >> n;
	if (n == 1) {
		cout << 1 << endl;
		return 0;
	}
	vector<int>ans;
	for (int i = 2;; i++) {
		n -= i;
		ans.push_back(i);
		if (n < i + 1)//无法继续拆分了
			break;
	}
	for (int i = ans.size() - 1; i >= 0; i--) {//从大到小，避免重复
		if (n == 0)
			break;
		ans[i]++;
		n--;
	}
	if (n == 1)//设拆分结束后前面有k-1个数2,3,...,k,故n最大为k,所以这里n要么是0要么是1
		ans[ans.size() - 1]++;
	for (int i = 0; i < ans.size(); i++) {
		cout << ans[i];
		if (i != ans.size() - 1)
			cout << ' ';
	}
	return 0;
}
